静态作用域 vs 动态作用域
---

### 中英文对照表
* 静态作用域（即词法作用域，以下统称静态作用域）：[Static Scope][Static Scope], also known as [Lexical Scope][Static Scope]
* 动态作用域：[Dynamic Scope](Dynamic Scope)

### 本文目标
本文力求读者在阅读完本文的[正文部分](#正文部分)（不包括[选读部分](#选读部分)）后，能够充分理解静态作用域和动态作用域在**实际应用中**的区别。为实现这个目标，我会以参考文献为准，并结合自己的理解，尽可能地使用通俗易懂但力求准确的语言来进行描述。

### 正文部分
#### 什么是作用域？
如果我们把函数也视为一种变量的话，那么简单来讲，所谓的[作用域][Scope]，或者说是变量的作用域，其实就是++变量的可见范围++。说白了，在程序执行时的某个节点上，你能够访问到某个变量，那么你就处在这个变量的作用域范围内，否则你就在这个变量的作用域范围之外。

#### 静态作用域 vs 动态作用域
##### 两者的应用
大多数现代的编程语言使用的都是静态作用域，包括：JavaScript、Java、Go等等。使用动态作用域的语言包括：一些Lisp的变种（例如：Emacs Lisp）、一些脚本语言（例如：Bash、PowerShell）以及一些模板语言等等。还有一些语言可以让用户在定义或者重新定义变量时选择使用静态作用域还是动态作用域（例如：Perl、Common Lisp）。

##### 两者的区别
静态作用域和动态作用域的根本区别在于对作用域的定义不同。静态作用域是由++源代码**决定**++的，也就是说，你的代码写好了，那么代码中的变量的作用域也就确定下来了。动态作用域是在++程序执行时**确定**下来++的。比如说有一个函数myFunc，函数myFunc中会访问一个变量myVar（假设函数myFunc内部并没有定义变量myVar），那么在静态作用域环境下，函数myFunc访问变量myVar的结果一定是在函数执行之前就已经确定下来的，而且是可以直接通过阅读源代码就知道的（访问到函数外的某个myVar变量，或者什么也访问不到）。而在动态作用域环境下，当函数myFunc被其他不同的函数调用时，它访问变量myVar的结果也可能不同（可能访问到同一个myVar变量，也可能访问到不同的myVar变量，也可能什么也访问不到）。

一起来看下面这段代码：
```js
function a() {
    var x = 1;	// x1

    function b() {
        x = 2;	// 改的是哪一个x呢？
    }

    function c() {
        var x;	// x2
        b();
    }

    c();
    console.log(x);
}

a();
```
为了方便描述，我给不同位置的变量x分别命名了别名x1和x2。接下来我们分别讨论上面这段代码在静态作用域和动态作用域环境下执行的过程、原因以及结果。

++在静态作用域环境下，变量的作用域是由源代码决定、并且是在编译阶段就确定下来的++。所以当函数b试图修改变量x时，它改动的永远是x1，即使它是在函数c中被调用、并且函数c中也有一个变量x的声明。所以最后打印的结果是2。

++在动态作用域环境下，变量的作用域是在程序执行时确定下来的++。当程序执行时，编译器会为每一个变量名维护一个全局的作用域栈，任何时候访问变量时，都从该变量对应的全局作用域栈的栈顶读取变量当前所处的作用域。我们以上面的代码为例，来看看在动态作用域环境下程序执行时都发生了什么：
1. 程序执行到x1处，编译器发现了变量x1的声明，并且变量名x是新的，于是为变量名x创建了一个全局的作用域栈并将`x => x1`压入栈中，此时变量x的作用域栈看起来就像这样：`[x => x1]`；
2. 程序执行到x2处，编译器发现了变量x2的声明，并且变量名x已经声明过了，于是将`x => x2`压入到变量x的作用域栈的栈顶，此时变量x的作用域栈就像这样：`[x => x1, x => x2]`；
3. 函数b开始执行并试图修改变量x，于是编译器从变量x的作用域栈的栈顶读取此时变量x的作用域，读取到的结果是`x => x2`，所以真正被修改的是x2，而x1的值保持不变。接下来函数b执行结束返回函数c；
4. 紧接着函数c也执行结束，同时对变量x的作用域栈执行出栈操作，此时变量x的作用域栈就像这样：`[x => x1]`；
5. 最后打印变量x时，编译器通过查看变量x的作用域栈的栈顶可以得知，此时的变量x指向的是x1，因为x1的值并没有发生改变（之前被修改的是x2），所以打印的结果为1。

再看看下面这段极为类似的代码：
```js
function a() {
    var x = 1;	// x1

    function b() {
        x = 2;	// 改的是哪一个x呢？
    }

    function c() {
        var x;	// x2
        b();
    }

    c();
    console.log(x);
    b();
    console.log(x);
}

a();
```
相比前面的示例，上面的代码主要多了一行对函数b的直接调用，所以当上面这段代码执行时，函数b被调用了两次，一次是调用函数c时对函数b的间接调用，另一次是对函数b的直接调用。

基于之前的分析我们可以得知，在静态作用域环境下，对函数b的两次调用修改的都是x2，所以两次打印的结果都是2。而在动态作用域环境下，第一次打印的结果和前面的示例一样是1。但是接下来直接调用函数b时，因为变量x的全局作用域栈的栈顶为`x => x1`，所以这一次改动的就是x1了，所以第二次打印的结果是2。与静态作用域不同的是，这里对函数b的两次调用修改的是不同的x变量。

### 选读部分

#### 深入理解静态作用域
在静态作用域中，变量的解析取决于变量在代码中的位置，也就是变量被定义的地方，编译器在编译阶段就可以生成一张变量名到引用对象的映射关系表。而动态作用域的变量解析依赖于变量被访问时所处的[执行上下文][Execution Context]。在实际应用中，静态作用域的变量解析会先从它所处的代码块开始找，如果没找到就继续找外层的代码块。而动态作用域的变量解析会先从当前正在执行的函数中开始找，如果没找到就继续到调用当前执行函数的函数中去找。

#### 深入理解动态作用域
在动态作用域中，编译器会为每一个变量名维护一个全局的作用域栈，名称相同的变量共享同一个作用域栈，名称不同的变量的作用域栈也不同。当执行程序进入一个新的[执行上下文][Execution Context]时（一般就是调用了一个函数），如果发现了变量声明x，那么就将当前执行上下文压入到变量x的作用域栈中（如果作用域栈不存在就创建一个），当执行程序离开当前执行上下文时，再对变量x的作用域栈执行出栈操作。任何时候访问变量x时，都从变量x的作用域栈的栈顶读取它当前所处的作用域。跟静态作用域不同，这个过程只能在执行阶段完成，这也是动态作用域名称的由来。

### 参考资料
1. [Static (Lexical) Scoping vs Dynamic Scoping (Pseudocode)](http://stackoverflow.com/questions/22394089/static-lexical-scoping-vs-dynamic-scoping-pseudocode)
2. [Scope (computer science)](https://en.wikipedia.org/wiki/Scope_&lpar;computer_science&rpar;)

[Scope]: https://en.wikipedia.org/wiki/Scope_(computer_science)
[Static Scope]: https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping
[Dynamic Scope]: https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scoping
[Execution Context]: https://en.wikipedia.org/wiki/Execution_context